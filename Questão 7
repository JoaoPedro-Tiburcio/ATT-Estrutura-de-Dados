Implementa√ß√£o do Selection Sort -
def selection_sort(arr):
    n = len(arr)
    
    # Itera sobre toda a lista
    for i in range(n):
        # Assume que o primeiro elemento da parte n√£o ordenada √© o menor
        min_index = i
        # Encontra o menor elemento na parte n√£o ordenada
        for j in range(i + 1, n):
            if arr[j] < arr[min_index]:
                min_index = j
        
        # Troca o menor elemento encontrado com o primeiro elemento da parte n√£o ordenada
        arr[i], arr[min_index] = arr[min_index], arr[i]
        
        # Exibe o estado da lista ap√≥s cada itera√ß√£o
        print(f"Itera√ß√£o {i + 1}: {arr}")

# Exemplo de uso
numeros = [64, 25, 12, 22, 11]
print("Lista inicial:", numeros)
selection_sort(numeros)
print("Lista ordenada:", numeros)

Como a Lista √© Organizada Passo a Passo -
Lista Inicial: [64, 25, 12, 22, 11]

Itera√ß√£o 1: Menor elemento na parte n√£o ordenada: 11.
Troca 11 com 64.
Lista: [11, 25, 12, 22, 64]

Itera√ß√£o 2: Menor elemento na parte n√£o ordenada: 12.
Troca 12 com 25.
Lista: [11, 12, 25, 22, 64]

Itera√ß√£o 3: Menor elemento na parte n√£o ordenada: 22.
Troca 22 com 25.
Lista: [11, 12, 22, 25, 64]

Itera√ß√£o 4: Menor elemento na parte n√£o ordenada: 25.
Mant√©m a posi√ß√£o, pois 25 j√° est√° no lugar correto.
Lista: [11, 12, 22, 25, 64]

Itera√ß√£o 5: Apenas um elemento restante (64), j√° est√° ordenado.
Lista Final: [11, 12, 22, 25, 64]

An√°lise do Desempenho em Listas de Diferentes Tamanhos -
Listas Pequenas:
O Selection Sort funciona bem para listas pequenas, pois sua simplicidade compensa a baixa efici√™ncia.
A troca de elementos √© f√°cil de entender, e o impacto de um algoritmo ùëÇ(ùëõ^2) em listas pequenas n√£o √© t√£o significativo.

Listas M√©dias:
O Selection Sort come√ßa a perder efici√™ncia em listas m√©dias, onde o n√∫mero de compara√ß√µes cresce rapidamente.
O algoritmo ainda √© vi√°vel para listas de tamanhos moderados (centenas de elementos), mas o tempo de execu√ß√£o come√ßa a se tornar um problema.

Listas Grandes:
Para listas grandes, o Selection Sort √© significativamente ineficiente devido √† sua complexidade ùëÇ(ùëõ^2).
A quantidade de compara√ß√µes e trocas necess√°rias torna o algoritmo impratic√°vel em grandes volumes de dados.
Algoritmos mais eficientes, como Merge Sort ou Quick Sort, s√£o preferidos.

Testando o Selection Sort em Diferentes Tamanhos -
import random
import time

def test_selection_sort():
    sizes = [10, 100, 1000, 5000]  # Tamanhos da lista para teste
    results = []

    for size in sizes:
        # Gera uma lista aleat√≥ria de tamanho 'size'
        arr = random.sample(range(1, size * 10), size)

        # Mede o tempo de execu√ß√£o do Selection Sort
        start_time = time.time()
        selection_sort(arr.copy())
        elapsed_time = time.time() - start_time

        # Armazena os resultados
        results.append({
            'size': size,
            'time': elapsed_time
        })

    # Exibe os resultados
    for result in results:
        print(f"Tamanho da lista: {result['size']}")
        print(f"Tempo de execu√ß√£o do Selection Sort: {result['time']:.6f} segundos")
        print('-' * 40)

# Executa o teste
test_selection_sort()
