ImplementaÃ§Ã£o do Shell Sort -
import time

# ImplementaÃ§Ã£o do Shell Sort com diferentes sequÃªncias de intervalo
def shell_sort(arr, sequence_type="shell"):
    n = len(arr)
    gaps = generate_gaps(n, sequence_type)

    # Ordena usando os gaps fornecidos pela sequÃªncia escolhida
    for gap in gaps:
        for i in range(gap, n):
            temp = arr[i]
            j = i

            # Insertion Sort modificado para usar o intervalo atual
            while j >= gap and arr[j - gap] > temp:
                arr[j] = arr[j - gap]
                j -= gap

            arr[j] = temp

# FunÃ§Ã£o para gerar as sequÃªncias de intervalo
def generate_gaps(n, sequence_type):
    if sequence_type == "shell":
        # SequÃªncia de Shell: n/2, n/4, ..., 1
        gaps = []
        gap = n // 2
        while gap > 0:
            gaps.append(gap)
            gap //= 2
        return gaps
    elif sequence_type == "knuth":
        # SequÃªncia de Knuth: 1, 4, 13, 40, ...
        gaps = []
        gap = 1
        while gap < n:
            gaps.append(gap)
            gap = gap * 3 + 1
        return gaps[::-1]  # Inverte para comeÃ§ar do maior para o menor
    elif sequence_type == "hibbard":
        # SequÃªncia de Hibbard: 1, 3, 7, 15, ...
        gaps = []
        k = 1
        gap = 2 ** k - 1
        while gap < n:
            gaps.append(gap)
            k += 1
            gap = 2 ** k - 1
        return gaps[::-1]  # Inverte para comeÃ§ar do maior para o menor

# FunÃ§Ã£o para comparar o desempenho do Shell Sort com diferentes sequÃªncias
def compare_shell_sort():
    sizes = [10**3, 10**4, 10**5]  # Tamanhos das listas para o teste
    sequences = ["shell", "knuth", "hibbard"]
    results = []

    for size in sizes:
        # Gera uma lista aleatÃ³ria de tamanho 'size'
        original_list = [i for i in range(size, 0, -1)]  # Lista reversa para pior caso
        for sequence in sequences:
            arr = original_list.copy()  # Faz uma cÃ³pia da lista original

            # Mede o tempo de execuÃ§Ã£o do Shell Sort para a sequÃªncia atual
            start_time = time.time()
            shell_sort(arr, sequence_type=sequence)
            elapsed_time = time.time() - start_time

            # Armazena os resultados
            results.append({
                'size': size,
                'sequence': sequence,
                'time': elapsed_time
            })

    # Imprime os resultados
    for result in results:
        print(f"Tamanho da lista: {result['size']}")
        print(f"SequÃªncia de Intervalo: {result['sequence'].capitalize()}")
        print(f"Tempo de execuÃ§Ã£o: {result['time']:.6f} segundos")
        print('-' * 40)

# Executa a comparaÃ§Ã£o
compare_shell_sort()

Como a Escolha da SequÃªncia de Intervalos Afeta a EficiÃªncia -
Shell Sequence:
A sequÃªncia de Shell usa divisÃµes por 2 sucessivas. Isso resulta em uma abordagem simples, mas nÃ£o muito eficiente para listas grandes.
O desempenho pode ser inconsistente, jÃ¡ que divisÃµes por 2 podem nÃ£o cobrir todas as possÃ­veis "ordenaÃ§Ãµes locais" adequadamente.

Knuth Sequence:
Essa sequÃªncia cresce mais lentamente que a sequÃªncia de Shell. Isso resulta em intervalos maiores inicialmente, permitindo que elementos distantes sejam ordenados com mais eficiÃªncia.
Ã‰ mais eficiente que a sequÃªncia de Shell na maioria dos casos e Ã© bem adaptada a listas de tamanho mÃ©dio a grande.

Hibbard Sequence:
A sequÃªncia 2^ğ‘˜âˆ’1 Ã© bem distribuÃ­da e tende a funcionar melhor para listas de tamanho mÃ©dio. No entanto, para listas muito grandes, pode haver problemas de eficiÃªncia, pois a Ãºltima lacuna Ã© sempre 1, o que implica mais comparaÃ§Ãµes do que outras sequÃªncias.
Uma caracterÃ­stica Ã© que, para listas mÃ©dias, oferece uma boa relaÃ§Ã£o entre trocas e comparaÃ§Ãµes.
